---
phase: 02-core-services-screen-light
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/src/main/java/com/anshul/screenlight/data/model/ScreenSettings.kt
  - app/src/main/java/com/anshul/screenlight/data/repository/SettingsRepository.kt
  - app/src/main/java/com/anshul/screenlight/data/sensor/AmbientLightManager.kt
  - app/src/main/java/com/anshul/screenlight/data/sensor/BatteryMonitor.kt
  - app/src/main/java/com/anshul/screenlight/di/AppModule.kt
autonomous: true

must_haves:
  truths:
    - "Settings persist across app restarts"
    - "Ambient light sensor returns lux value"
    - "Battery level is readable without registering receiver"
  artifacts:
    - path: "app/src/main/java/com/anshul/screenlight/data/model/ScreenSettings.kt"
      provides: "Data class for brightness/color settings"
      contains: "data class ScreenSettings"
    - path: "app/src/main/java/com/anshul/screenlight/data/repository/SettingsRepository.kt"
      provides: "DataStore-backed settings persistence"
      contains: "DataStore<Preferences>"
    - path: "app/src/main/java/com/anshul/screenlight/data/sensor/AmbientLightManager.kt"
      provides: "Light sensor wrapper"
      contains: "TYPE_LIGHT"
    - path: "app/src/main/java/com/anshul/screenlight/data/sensor/BatteryMonitor.kt"
      provides: "Battery level checker"
      contains: "ACTION_BATTERY_CHANGED"
  key_links:
    - from: "SettingsRepository.kt"
      to: "DataStore"
      via: "constructor injection"
      pattern: "@Inject constructor.*DataStore"
    - from: "AppModule.kt"
      to: "SensorManager"
      via: "system service provider"
      pattern: "getSystemService.*SENSOR_SERVICE"
---

<objective>
Create data layer with settings persistence, ambient light detection, and battery monitoring

Purpose: Provide the data primitives that the UI layer needs to save settings, detect dark environments, and monitor battery
Output: SettingsRepository with DataStore persistence, AmbientLightManager for lux readings, BatteryMonitor for battery level
</objective>

<execution_context>
@/Users/anshul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/anshul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-services-screen-light/02-RESEARCH.md
@.planning/phases/02-core-services-screen-light/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScreenSettings model and SettingsRepository with DataStore</name>
  <files>app/src/main/java/com/anshul/screenlight/data/model/ScreenSettings.kt, app/src/main/java/com/anshul/screenlight/data/repository/SettingsRepository.kt</files>
  <action>
Create data/model/ScreenSettings.kt:
```kotlin
package com.anshul.screenlight.data.model

import androidx.compose.ui.graphics.Color

/**
 * Screen settings for the light display.
 *
 * @param brightness Screen brightness from 0.0 (off) to 1.0 (full)
 * @param colorArgb Color as ARGB integer for persistence
 */
data class ScreenSettings(
    val brightness: Float = 1.0f,
    val colorArgb: Int = DEFAULT_COLOR_ARGB
) {
    val color: Color get() = Color(colorArgb)

    companion object {
        // Deep red for night vision mode
        val NIGHT_VISION_COLOR = Color(0xFF8B0000)
        const val NIGHT_VISION_COLOR_ARGB = 0xFF8B0000.toInt()

        // Default: warm white
        const val DEFAULT_COLOR_ARGB = 0xFFFFF8E7.toInt()

        fun default() = ScreenSettings()

        fun nightVision() = ScreenSettings(colorArgb = NIGHT_VISION_COLOR_ARGB)
    }
}
```

Create data/repository/SettingsRepository.kt:
```kotlin
package com.anshul.screenlight.data.repository

import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.floatPreferencesKey
import androidx.datastore.preferences.core.intPreferencesKey
import com.anshul.screenlight.data.model.ScreenSettings
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SettingsRepository @Inject constructor(
    private val dataStore: DataStore<Preferences>
) {
    private companion object {
        val BRIGHTNESS_KEY = floatPreferencesKey("brightness")
        val COLOR_KEY = intPreferencesKey("color_argb")
    }

    val settings: Flow<ScreenSettings> = dataStore.data.map { prefs ->
        ScreenSettings(
            brightness = prefs[BRIGHTNESS_KEY] ?: 1.0f,
            colorArgb = prefs[COLOR_KEY] ?: ScreenSettings.DEFAULT_COLOR_ARGB
        )
    }

    suspend fun updateBrightness(brightness: Float) {
        dataStore.edit { prefs ->
            prefs[BRIGHTNESS_KEY] = brightness.coerceIn(0f, 1f)
        }
    }

    suspend fun updateColor(colorArgb: Int) {
        dataStore.edit { prefs ->
            prefs[COLOR_KEY] = colorArgb
        }
    }

    suspend fun updateSettings(settings: ScreenSettings) {
        dataStore.edit { prefs ->
            prefs[BRIGHTNESS_KEY] = settings.brightness.coerceIn(0f, 1f)
            prefs[COLOR_KEY] = settings.colorArgb
        }
    }
}
```
  </action>
  <verify>Run `./gradlew assembleDebug` to verify compilation. Check that SettingsRepository can be injected (build success confirms Hilt wiring).</verify>
  <done>ScreenSettings data class exists with night vision defaults, SettingsRepository persists brightness/color to DataStore via Flow.</done>
</task>

<task type="auto">
  <name>Task 2: Create AmbientLightManager and BatteryMonitor sensor utilities</name>
  <files>app/src/main/java/com/anshul/screenlight/data/sensor/AmbientLightManager.kt, app/src/main/java/com/anshul/screenlight/data/sensor/BatteryMonitor.kt, app/src/main/java/com/anshul/screenlight/di/AppModule.kt</files>
  <action>
Create data/sensor/AmbientLightManager.kt:
```kotlin
package com.anshul.screenlight.data.sensor

import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Manages ambient light sensor readings.
 *
 * Dark threshold: < 50 lux (typical indoor dim lighting)
 */
@Singleton
class AmbientLightManager @Inject constructor(
    private val sensorManager: SensorManager
) {
    private val lightSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)

    /**
     * Whether the device has an ambient light sensor.
     */
    val hasLightSensor: Boolean get() = lightSensor != null

    /**
     * Get current ambient light level as a one-shot reading.
     * Returns null if sensor unavailable or reading fails.
     *
     * @param timeoutMs Maximum time to wait for a reading
     */
    suspend fun getCurrentLux(timeoutMs: Long = 500): Float? {
        if (lightSensor == null) return null

        return kotlinx.coroutines.withTimeoutOrNull(timeoutMs) {
            var lux: Float? = null
            val listener = object : SensorEventListener {
                override fun onSensorChanged(event: SensorEvent) {
                    lux = event.values[0]
                }
                override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {}
            }

            sensorManager.registerListener(
                listener,
                lightSensor,
                SensorManager.SENSOR_DELAY_FASTEST
            )

            // Wait for a reading
            while (lux == null) {
                kotlinx.coroutines.delay(10)
            }

            sensorManager.unregisterListener(listener)
            lux
        }
    }

    /**
     * Observe ambient light levels as a Flow.
     * Automatically unregisters when collection stops.
     */
    fun observeAmbientLight(): Flow<Float> = callbackFlow {
        if (lightSensor == null) {
            close()
            return@callbackFlow
        }

        val listener = object : SensorEventListener {
            override fun onSensorChanged(event: SensorEvent) {
                trySend(event.values[0])
            }
            override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {}
        }

        sensorManager.registerListener(
            listener,
            lightSensor,
            SensorManager.SENSOR_DELAY_NORMAL
        )

        awaitClose {
            sensorManager.unregisterListener(listener)
        }
    }

    companion object {
        /** Lux threshold below which environment is considered "dark" */
        const val DARK_THRESHOLD_LUX = 50f
    }
}
```

Create data/sensor/BatteryMonitor.kt:
```kotlin
package com.anshul.screenlight.data.sensor

import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.BatteryManager
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Monitors battery level using sticky intent pattern.
 * No BroadcastReceiver needed - sticky intent provides current state.
 */
@Singleton
class BatteryMonitor @Inject constructor(
    @ApplicationContext private val context: Context
) {
    /**
     * Get current battery percentage (0-100).
     * Returns -1 if unable to determine.
     */
    fun getBatteryPercentage(): Int {
        val batteryStatus: Intent? = context.registerReceiver(
            null,
            IntentFilter(Intent.ACTION_BATTERY_CHANGED)
        )

        return batteryStatus?.let { intent ->
            val level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)
            val scale = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)
            if (level >= 0 && scale > 0) {
                (level * 100) / scale
            } else {
                -1
            }
        } ?: -1
    }

    /**
     * Check if battery is below low threshold.
     */
    fun isLowBattery(): Boolean {
        val percentage = getBatteryPercentage()
        return percentage in 0 until LOW_BATTERY_THRESHOLD
    }

    /**
     * Check if device is currently charging.
     */
    fun isCharging(): Boolean {
        val batteryStatus: Intent? = context.registerReceiver(
            null,
            IntentFilter(Intent.ACTION_BATTERY_CHANGED)
        )

        return batteryStatus?.let { intent ->
            val status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)
            status == BatteryManager.BATTERY_STATUS_CHARGING ||
                status == BatteryManager.BATTERY_STATUS_FULL
        } ?: false
    }

    companion object {
        /** Battery percentage threshold for low battery warning */
        const val LOW_BATTERY_THRESHOLD = 15
    }
}
```

Update di/AppModule.kt to provide SensorManager:
```kotlin
package com.anshul.screenlight.di

import android.content.Context
import android.hardware.SensorManager
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.preferencesDataStore
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "screen_settings")

@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun provideDataStore(@ApplicationContext context: Context): DataStore<Preferences> {
        return context.dataStore
    }

    @Provides
    @Singleton
    fun provideSensorManager(@ApplicationContext context: Context): SensorManager {
        return context.getSystemService(Context.SENSOR_SERVICE) as SensorManager
    }
}
```
  </action>
  <verify>Run `./gradlew assembleDebug` to verify all classes compile and Hilt wiring is correct. Run `./gradlew testDebugUnitTest` to ensure no regressions.</verify>
  <done>AmbientLightManager provides one-shot and Flow-based lux readings, BatteryMonitor provides battery percentage via sticky intent pattern, both injectable via Hilt.</done>
</task>

</tasks>

<verification>
1. `./gradlew assembleDebug` builds successfully
2. `./gradlew testDebugUnitTest` passes
3. `./gradlew detekt` has no violations
4. SettingsRepository, AmbientLightManager, BatteryMonitor are all injectable singletons
</verification>

<success_criteria>
- ScreenSettings model has brightness (Float) and color (Int ARGB)
- SettingsRepository reads/writes settings via DataStore Flow
- AmbientLightManager returns lux value (or null if no sensor)
- BatteryMonitor returns battery percentage without BroadcastReceiver
- All components are Hilt @Singleton with @Inject constructor
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-services-screen-light/02-02-SUMMARY.md`
</output>
