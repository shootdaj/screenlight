---
phase: 03-gesture-controls-led-flashlight
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/main/java/com/anshul/screenlight/data/sensor/TiltGestureManager.kt
  - app/src/main/java/com/anshul/screenlight/data/device/FlashlightController.kt
  - app/src/main/java/com/anshul/screenlight/di/AppModule.kt
autonomous: true

must_haves:
  truths:
    - "TiltGestureManager emits pitch/roll angles when tilt sensor is observed"
    - "FlashlightController can toggle LED flashlight on/off"
    - "FlashlightController tracks torch state via TorchCallback"
    - "Both managers are injectable via Hilt as singletons"
  artifacts:
    - path: "app/src/main/java/com/anshul/screenlight/data/sensor/TiltGestureManager.kt"
      provides: "Cold Flow for device tilt observation using TYPE_GAME_ROTATION_VECTOR"
      exports: ["TiltGestureManager", "TiltData"]
    - path: "app/src/main/java/com/anshul/screenlight/data/device/FlashlightController.kt"
      provides: "CameraManager torch control with state tracking"
      exports: ["FlashlightController"]
    - path: "app/src/main/java/com/anshul/screenlight/di/AppModule.kt"
      provides: "CameraManager DI provider"
      contains: "provideCameraManager"
  key_links:
    - from: "TiltGestureManager"
      to: "SensorManager.getDefaultSensor(TYPE_GAME_ROTATION_VECTOR)"
      via: "constructor injection"
      pattern: "Sensor.TYPE_GAME_ROTATION_VECTOR"
    - from: "FlashlightController"
      to: "CameraManager.setTorchMode()"
      via: "system service"
      pattern: "cameraManager.setTorchMode"
---

<objective>
Create data layer components for tilt gesture sensing and LED flashlight control.

Purpose: Enable eyes-free brightness/color adjustment via device orientation and LED torch toggle. These managers follow the existing Cold Flow pattern from AmbientLightManager (Phase 2) for lifecycle-aware, battery-efficient sensor observation.

Output: Two injectable singletons - TiltGestureManager for pitch/roll tilt detection using game rotation vector sensor, and FlashlightController for CameraManager-based torch control with TorchCallback state synchronization.
</objective>

<execution_context>
@/Users/anshul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/anshul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-gesture-controls-led-flashlight/03-RESEARCH.md

# Existing pattern to follow
@app/src/main/java/com/anshul/screenlight/data/sensor/AmbientLightManager.kt

# DI module to extend
@app/src/main/java/com/anshul/screenlight/di/AppModule.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TiltGestureManager with Cold Flow pattern</name>
  <files>app/src/main/java/com/anshul/screenlight/data/sensor/TiltGestureManager.kt</files>
  <action>
Create TiltGestureManager following the AmbientLightManager pattern:

1. **Class structure:**
   - @Singleton with @Inject constructor taking SensorManager
   - Private rotationSensor: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)
   - Property `val hasSensor: Boolean` returns rotationSensor != null

2. **TiltData data class:**
   - `pitch: Float` - Forward/back tilt (-90 face down to +90 face up)
   - `roll: Float` - Left/right tilt (-180 to +180)

3. **observeTilt(): Flow<TiltData>** using callbackFlow:
   - Return empty flow if sensor is null (close() and return)
   - Create FloatArray(9) for rotationMatrix and FloatArray(3) for orientation
   - Register SensorEventListener with SENSOR_DELAY_UI (~60ms, good for gesture response)
   - In onSensorChanged:
     - Call SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)
     - Call SensorManager.getOrientation(rotationMatrix, orientation)
     - Extract pitch = Math.toDegrees(orientation[1].toDouble()).toFloat()
     - Extract roll = Math.toDegrees(orientation[2].toDouble()).toFloat()
     - trySend(TiltData(pitch, roll))
   - In awaitClose: sensorManager.unregisterListener(listener)

4. **TiltMapper object** (companion or separate object):
   - pitchToBrightness(pitch: Float): Float
     - Map pitch from [-45, 0] to [0, 1] (phone upright-ish to flat = dim to bright)
     - Clamp input to range, normalize output to 0..1
   - rollToColorIndex(roll: Float, colorCount: Int): Int
     - Map roll from [-45, +45] to [0, colorCount-1]
     - Left tilt = warm colors (low index), right tilt = cool colors (high index)
     - Round and clamp output to valid index range

**Critical:** Use TYPE_GAME_ROTATION_VECTOR not deprecated TYPE_ORIENTATION. This provides fused accelerometer+gyroscope data without magnetometer noise.
  </action>
  <verify>
- `./gradlew assembleDebug` compiles without errors
- TiltGestureManager class exists with observeTilt() returning Flow<TiltData>
- TiltMapper functions exist and map angles to values correctly
- No lint warnings about deprecated sensor types
  </verify>
  <done>
TiltGestureManager injectable singleton that emits pitch/roll angles via Cold Flow when observed, with TiltMapper utility functions for converting angles to brightness (0-1) and color index (0 to N-1).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FlashlightController with TorchCallback</name>
  <files>
    app/src/main/java/com/anshul/screenlight/data/device/FlashlightController.kt
    app/src/main/java/com/anshul/screenlight/di/AppModule.kt
  </files>
  <action>
**Part A: Create FlashlightController**

Create FlashlightController in new package `data/device/`:

1. **Class structure:**
   - @Singleton with @Inject constructor taking @ApplicationContext Context
   - Private cameraManager obtained via context.getSystemService(Context.CAMERA_SERVICE)
   - Private _torchState = MutableStateFlow(false)
   - Public torchState: StateFlow<Boolean> = _torchState.asStateFlow()
   - Private cameraId: String? - find camera with FLASH_INFO_AVAILABLE

2. **Init block:**
   - Find cameraId: cameraManager.cameraIdList.firstOrNull that has getCameraCharacteristics(id).get(CameraCharacteristics.FLASH_INFO_AVAILABLE) == true
   - Register TorchCallback to track torch state:
     ```kotlin
     cameraManager.registerTorchCallback(object : CameraManager.TorchCallback() {
         override fun onTorchModeChanged(cameraId: String, enabled: Boolean) {
             if (cameraId == this@FlashlightController.cameraId) {
                 _torchState.value = enabled
             }
         }
     }, null)
     ```

3. **Properties and methods:**
   - `val hasFlash: Boolean` - returns cameraId != null
   - `fun toggleTorch()` - calls setTorchMode with !_torchState.value, wrapped in try-catch for CameraAccessException (silently fail if camera in use)
   - `fun setTorch(enabled: Boolean)` - calls setTorchMode with enabled, wrapped in try-catch

**Important:** No CAMERA permission required for setTorchMode() since API 23.

**Part B: Add CameraManager to AppModule**

Add provider in AppModule.kt:

```kotlin
@Provides
@Singleton
fun provideCameraManager(
    @ApplicationContext context: Context
): CameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager
```

Update FlashlightController to inject CameraManager directly instead of Context if cleaner:
```kotlin
class FlashlightController @Inject constructor(
    private val cameraManager: CameraManager
) { ... }
```
  </action>
  <verify>
- `./gradlew assembleDebug` compiles without errors
- FlashlightController class exists with toggleTorch(), setTorch(), torchState, hasFlash
- CameraManager provider exists in AppModule
- No CameraAccessException crashes when camera unavailable (try-catch handling)
  </verify>
  <done>
FlashlightController injectable singleton that controls LED torch via CameraManager, exposes torch state as StateFlow, and gracefully handles camera-in-use scenarios.
  </done>
</task>

</tasks>

<verification>
Run verification commands:
```bash
./gradlew assembleDebug
./gradlew testDebugUnitTest
./gradlew detekt
```

All three must pass. No unit tests expected for sensor/camera hardware access - these require instrumented tests or manual device testing.
</verification>

<success_criteria>
1. TiltGestureManager.kt exists in data/sensor/ with observeTilt() Cold Flow
2. TiltData data class defined with pitch/roll Float fields
3. TiltMapper object provides pitchToBrightness() and rollToColorIndex() functions
4. FlashlightController.kt exists in data/device/ with toggleTorch() and torchState
5. CameraManager provider added to AppModule.kt
6. Build compiles, tests pass, detekt clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-gesture-controls-led-flashlight/03-01-SUMMARY.md`
</output>
